REBOL [
    System: "REBOL [R3] Language Interpreter and Run-time Environment"
    Title: "Make the R3 Core Makefile"
    Rights: {
        Copyright 2012 REBOL Technologies
        Copyright 2012-2017 Rebol Open Source Contributors
        REBOL is a trademark of REBOL Technologies
    }
    License: {
        Licensed under the Apache License, Version 2.0
        See: http://www.apache.org/licenses/LICENSE-2.0
    }
    Purpose: {
        Build a new makefile for a given platform.

        The reason that Rebol is not used to drive the build directly is to
        make it possible to port to any platform which supports GNU make.
        A R3-Alpha or Ren-C interpreter is thus only needed to produce the
        files, which can be done on a different platform, with the products
        transferred over to the new system which bootstrap is being done on.
    }
    Note: [
        "This runs relative to ../tools directory."
        "Make OS-specific changes to the systems.r file."
    ]
]

do %r2r3-future.r
do %common.r
do %common-emitter.r


path-host: %../os/
path-make: %../../make/
path-incl: %../../src/include/


;
; PROCESS COMMAND LINE ARGS
;
; Arguments are like `r3 %make-make.r A=B X=Y`, so turn that into an args
; object with keys and values (e.g. args/A = "B").  Values are STRING!
;

args: parse-args system/options/args


;
; IMPORT PLATFORM CONFIGURATION TO `CONFIG` OBJECT (from %systems.r)
;
; If OS_ID is not provided, it will be detected.
;

do %systems.r

config: case [
    any [blank? args/OS_ID | args/OS_ID = "detect"] [
        config-system blank
    ]
    true [
        config-system args/OS_ID
    ]
]

print ["Option set for building:" config/id config/os-name]

flag?: function [
    {Test if a flag is applicable for the current platform (see %systems.r)}
    'flag [word!]
][
    not blank? find config/build-flags flag
]


;
; PROCESS LIST OF INPUT C AND HEADER FILES FROM %FILE-BASE.R
;

file-base: has load %file-base.r

; Collect OS-specific host files.
;
os-specific-objs: select file-base to word! unspaced ["os-" config/os-base]
unless os-specific-objs [
    fail [
        "make-make.r requires os-specific obj list in file-base.r"
        "Nothing was provided for" unspaced ["os-" config/os-base]
    ]
]

; The + sign is used to tell the make-header.r script that the file is
; generated.  We don't care about that here
;
remove-each item file-base/core [item = '+]

; The + sign is used to tell the make-os-ext.r script to scan a host kit file
; for headers (the way make-headers.r does).  But we don't care about that
; here in make-make.r... so remove any + signs we find before processing.
;
remove-each item file-base/os [item = '+]
remove-each item os-specific-objs [item = '+]

if flag? +SC [remove find os-specific-objs 'host-readline.c]


emit [

{# REBOL Makefile -- Generated by make-make.r (!!! EDITS WILL BE LOST !!!)
# This automatically produced file was created } now newline

newline

{# This makefile is intentionally kept simple to make builds possible on
# a wide range of target platforms.  While this generated file has several
# capabilities, it is not tracked by version control.  So to kick off the
# process you need to use the tracked bootstrap makefile:
#
#     make -f makefile.boot
#
# See the comments in %makefile.boot for more information on the workings of
# %make-make.r and what the version numbers mean.
#
# To cross-compile using a different toolchain and include files:
#
#     $TOOLS - should point to bin where gcc is found
#     $INCL  - should point to the dir for includes
#
# Example make:
#
#     make TOOLS=~/amiga/amiga/bin/ppc-amigaos- INCL=/SDK/newlib/include
#
# !!! Efforts to be able to have Rebol build itself in absence of a make
# tool are being considered.  Please come chime in on chat if you are
# interested in that and other projects, or need support while building:
#
# http://rebolsource.net/go/chat-faq
#
}

{OS_ID?=} space (config/id) newline

newline

{GIT_COMMIT?=} space (any [args/GIT_COMMIT "unknown"]) newline

newline

{DEBUG_FLAGS?=} space (
    case [
        any [blank? args/DEBUG | args/DEBUG = "yes"] [
            debug: true
            "-g -O0"
        ]
        args/DEBUG = "no" [
            debug: false
            ; http://stackoverflow.com/questions/9229978/

            "-DNDEBUG -O2"
        ]
        true [
            fail ["DEBUG must be yes or no, not" (args/DEBUG)]
        ]
    ]
) newline

newline

(
    case [
        args/SANITIZE = "yes" [
            unspaced [
                {SANITIZE_FLAGS= -fno-omit-frame-pointer -fsanitize=address}
                    space {-L/usr/local/lib -I/usr/local/include} newline
                {SANITIZE_LINK_FLAGS= -lasan -fsanitize=address} newline
            ]
        ]
        any [blank? args/SANITIZE | args/SANITIZE = "no"] [
            unspaced [
                {SANITIZE_FLAGS=} newline
                {SANITIZE_LINK_FLAGS=} newline
            ]
        ]
        true [
            fail ["SANITIZE must be yes or no, not" (args/SANITIZE)]
        ]
    ]
) newline

newline

{LANGUAGE_FLAGS?=} space case [
    any [blank? args/STANDARD | args/STANDARD = "c"] [
        cplusplus: false
        ""
    ]
    find ["c99" "gnu99"] args/STANDARD [
        cplusplus: false
        unspaced ["--std=" args/STANDARD]
    ]
    "c++" = args/STANDARD [
        cplusplus: true
        "-x c++"
    ]
    find ["c++0x" "c++11" "c++14" "c++17"] args/STANDARD [
        cplusplus: true
        unspaced ["-x c++" space "--std=" args/STANDARD]
    ]
    true [
        fail [
            "STANDARD needs to be c, c99, gnu99, c++, c++11, c++14, c++17,"
            "not" (args/STANDARD)
        ]
    ]
] space case [
    any [blank? args/STATIC | args/STATIC = "no"] [
        ;
        ; !!! Is there a way to explicitly request dynamic linking?
        ;
        {}
    ]
    args/STATIC = "yes" [
        either cplusplus [
            "-static-libgcc -static-libstdc++"
        ][
            "-static-libgcc"
        ]
    ]
    true [
        fail ["STATIC needs to be yes or no, not" (args/STATIC)]
    ]
] newline

{RIGOROUS_FLAGS?=} space (
    case [
        args/RIGOROUS = "yes" [
            spaced [
                "-Werror" ;-- convert warnings to errors

                ; !!! Coming soon, need to vet the source for max warnings

                ;"--pedantic" "-Wextra" "-Wall" "-Wchar-subscripts"
                ;"-Wwrite-strings" "-Wundef" "-Wformat=2"
                ;"-Wdisabled-optimization" "-Wcast-qual"
                ;"-Wlogical-op" "-Wstrict-overflow=5" "-Wredundant-decls"
                ;"-Woverflow" "-Wpointer-arith" "-Wparentheses" "-Wmain"
                ;"-Wsign-compare" "-Wtype-limits"
            ]

        ]
        any [blank? args/RIGOROUS | args/RIGOROUS = "no"] [
            {}
        ]
        true [
            fail ["RIGOROUS must be yes or no, not" (args/RIGOROUS)]
        ]
    ]
) newline
 
{# For the build toolchain:
CC=} space (either cplusplus ["$(TOOLS)g++"] ["$(TOOLS)gcc"]) newline

newline

{NM= $(TOOLS)nm} newline

newline

{# CP allows different copy progs:
CP?=} space (either flag? COP ["copy"] ["cp"]) newline

{# LS allows different directory list progs:
LS?=} space (either flag? DIR ["dir"] ["ls -l"]) newline

{# UP - some systems do not use ../
UP?=} space (either flag? -SP [""] [".."]) newline

{# CD - some systems do not use ./
CD?=} space (either flag? -SP [""] ["./"]) newline

newline

either debug [
    ; Need something that can take a filename, directory listing will do
    {STRIP= $(LS)}
][
    {STRIP= $(TOOLS)strip}
] newline

newline

{# Special tools:
T= $(UP)/src/tools
# Paths used by make:
S= ../src
R= $S/core

INCL ?= .
I= -I$(INCL) -I$S/include/ -I$S/codecs/
}

newline

{TO_OS_BASE?=} space (uppercase to-c-name [{TO_} config/os-base]) newline
{TO_OS_NAME?=} space (uppercase to-c-name [{TO_} config/os-name]) newline

newline

{BIN_SUFFIX=} space (either flag? EXE [".exe"] [""]) newline

newline

case [
    args/WITH_FFI = "static" [
        unspaced [
            {FFI_FLAGS=`pkg-config --cflags libffi` -DHAVE_LIBFFI_AVAILABLE}
                newline
            {#only statically link ffi}
                newline
            {FFI_LIBS=-Wl,-Bstatic `pkg-config --libs libffi`}
                space {-Wl,-Bdynamic -lpthread}
                newline
         ]
    ]
    args/WITH_FFI = "dynamic" [
        unspaced [
            {FFI_FLAGS=`pkg-config --cflags libffi` -DHAVE_LIBFFI_AVAILABLE}
                newline
            {FFI_LIBS=`pkg-config --libs libffi`}
                space {-lpthread}
                newline
         ]
    ]
    any [blank? args/WITH_FFI | args/WITH_FFI = "no"] [
        unspaced [
            {FFI_FLAGS=} newline
            {FFI_LIBS=} newline
        ]
    ]
    true [
        fail ["WITH_FFI must be static, dynamic or no, not" (args/WITH_FFI)]
    ]
]

newline
]


;
; LIBRARY FLAGS
;
emit [
    {RAPI_FLAGS= $(LANGUAGE_FLAGS) $(DEBUG_FLAGS)}
        space {$(SANITIZE_FLAGS) $(RIGOROUS_FLAGS)}
]

for-each [flag switches] compiler-flags [
    if all [flag? (flag) | switches] [
        emit [space switches]
    ]
]

for-each [flag switches] lib-compiler-flags [
    if all [flag? (flag) | switches] [
        emit [space switches]
    ]
]

emit newline

;
; HOST FLAGS
;

emit [
    {HOST_FLAGS= $(LANGUAGE_FLAGS) $(DEBUG_FLAGS) $(SANITIZE_FLAGS) -DREB_EXE}
]

for-each [flag switches] compiler-flags [
    if all [flag? (flag) | switches] [
        emit [space switches]
    ]
]

emit newline

emit [
newline
{# Flags for core and for host:
RFLAGS= -c -D$(TO_OS_BASE) -D$(TO_OS_NAME) -DREB_API  $(RAPI_FLAGS) $(FFI_FLAGS) $I
HFLAGS= -c -D$(TO_OS_BASE) -D$(TO_OS_NAME) -DREB_CORE $(HOST_FLAGS) $I}

newline newline
]


;
; LINKER FLAGS
;
; See %systems.r for the abbreviated table of linker flags per-system
;

emit ["CLIB= $(SANITIZE_LINK_FLAGS)" space]

for-each [flag switches] linker-flags [
    if all [flag? (flag) | switches] [
        emit [switches space]
    ]
]

emit newline
emit newline


;
; REBOL TOOLING
;

emit [
{# REBOL is needed to build various include files:
REBOL_TOOL= r3-make$(BIN_SUFFIX)
REBOL= $(CD)$(REBOL_TOOL) -qs

# For running tests, ship, build, etc.
R3_TARGET= r3$(BIN_SUFFIX)
R3= $(CD)$(R3_TARGET) -qs

### Build targets:
top:
    $(MAKE) $(R3_TARGET)

update:
    -cd $(UP)/; cvs -q update src

clean:
    @-rm -rf $(R3_TARGET) libr3.so objs/
    @-find ../src -name 'tmp-*' -exec rm -f {} \;
    @-grep -l "AUTO-GENERATED FILE" ../src/include/*.h |grep -v sys-zlib.h|xargs rm 2>/dev/null || true

all:
    $(MAKE) clean
    $(MAKE) prep
    $(MAKE) $(R3_TARGET)
    $(MAKE) lib
    $(MAKE) host$(BIN_SUFFIX)

prep: $(REBOL_TOOL)
    $(REBOL) $T/make-natives.r
    $(REBOL) $T/make-headers.r
    $(REBOL) $T/make-boot.r OS_ID=$(OS_ID) GIT_COMMIT=$(GIT_COMMIT)
    $(REBOL) $T/make-host-init.r
    $(REBOL) $T/make-os-ext.r
    $(REBOL) $T/make-host-ext.r
    $(REBOL) $T/make-reb-lib.r} newline
    ;
    ;-- more lines added to this section by the boot extensions 
]


;
; EMIT BOOT EXTENSIONS
;
; The concept in Ren-C is to allow various pieces of Rebol to be chosen as
; either built into the EXE, available as a dynamic library, or not built
; at all.  This is new work, and for starters just cryptography and image
; codecs are covered.  But the concept behind it is that even the /VIEW
; GUI behavior itself would be such an extension.
;

boot-extension-src: copy []
extensions: copy ""
for-each [is-built-in ext-name ext-src modules] file-base/extensions [
    unless '+ = is-built-in [
        continue
    ]

    unless empty? extensions [append extensions ","]
    append extensions to string! ext-name
    append/only boot-extension-src ext-src ; ext-src is a path!, /ONLY needed

    ; Though not scanned for natives, there can be additional C files
    ; specified for a module.
    ;
    for-each m modules [
        m-spec: find file-base/modules m

        ; Currently, only the extension's main C file is scanned for natives.
        ; m-spec/2 is that main C file, see %file-base.r's "modules"
        ;
        emit [
            {    $(REBOL) $T/make-ext-natives.r} space
            {MODULE=} m-spec/1 space {SRC=} m-spec/2 newline
        ]

        append/only boot-extension-src m-spec/2 ; main C file
        append boot-extension-src m-spec/3 ; other files of the module
    ]
]

emit [
    {    $(REBOL) $T/make-boot-ext-header.r EXTENSIONS=} extensions newline
]



emit [
{zlib:
    $(REBOL) $T/make-zlib.r

### Provide more info if make fails due to no local Rebol build tool:
tmps: $S/include/tmp-bootdefs.h

$S/include/tmp-bootdefs.h: $(REBOL_TOOL)
    $(MAKE) prep

$(REBOL_TOOL):
    $(MAKE) -f makefile.boot $(REBOL_TOOL)

### Post build actions
purge:
    -rm libr3.*
    -rm host$(BIN_SUFFIX)
    $(MAKE) lib
    $(MAKE) host$(BIN_SUFFIX)

test:
    $(CP) $(R3_TARGET) $(UP)/src/tests/
    $(R3) $S/tests/test.r

install:
    sudo cp $(R3_TARGET) /usr/local/bin

ship:
    $(R3) $S/tools/upload.r

build: libr3.so
    $(R3) $S/tools/make-build.r

cln:
    rm libr3.* r3.o

check:
    $(STRIP) -s -o r3.s $(R3_TARGET)
    $(STRIP) -x -o r3.x $(R3_TARGET)
    $(STRIP) -X -o r3.X $(R3_TARGET)
    $(LS) r3*

}]


;
; EMIT OBJ FILE DEPENDENCIES
;
; !!! The use of split path to remove directory in TO-OBJ had been commented
; out, but was re-added to incorporate the paths on codecs in a stop-gap
; measure to use make-make.r with Atronix repo
;

to-obj: function [
    "Create .o object filename (with no dir path)."
    file
][
    file: (comment [to-file file] second split-path to-file file)
    head change back tail file "o"
]

emit-obj-files: procedure [
    "Output a line-wrapped list of object files."
    files [block!]
][
    num-on-line: 0
    pending: _
    for-each file files [
        if pending [
            emit pending
            pending: _
        ]

        emit [%objs/ to-obj file space]
        
        if (num-on-line == 4) [
            pending: unspaced ["\" newline spaced-tab]
            num-on-line: 0
        ]
        num-on-line: num-on-line + 1
    ]
    emit [newline newline]
]

emit ["OBJS =" space]
emit-obj-files append copy file-base/core boot-extension-src

emit ["HOST =" space]
emit-obj-files append copy file-base/os os-specific-objs

emit {
# Directly linked r3 executable:
$(R3_TARGET): tmps objs $(OBJS) $(HOST)
    $(CC) -o $(R3_TARGET) $(OBJS) $(HOST) $(CLIB) $(FFI_LIBS)
    $(STRIP) $(R3_TARGET)
    $(LS) $(R3_TARGET)

objs:
    mkdir -p objs
}


;
; EMIT STATIC OR DYNAMIC LIBRARY
;
; Depending on the kind of target being built the R3-library can be either
; static or dynamic
;

makefile-so: {
lib: libr3.so

# PUBLIC: Shared library:
# NOTE: Did not use "-Wl,-soname,libr3.so" because won't find .so in local dir.
libr3.so: $(OBJS)
    $(CC) -o libr3.so -shared $(OBJS) $(CLIB) $(FFI_LIBS)
    $(STRIP) libr3.so
    $(LS) libr3.so

# PUBLIC: Host using the shared lib:
host$(BIN_SUFFIX): $(HOST)
    $(CC) -o host$(BIN_SUFFIX) $(HOST) libr3.so $(CLIB)
    $(STRIP) host$(BIN_SUFFIX)
    $(LS) host$(BIN_SUFFIX)
    echo "export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH"
}

makefile-dyn: {
lib: libr3.dylib

# Private static library (to be used below for OSX):
libr3.dylib: $(OBJS)
    ld -r -o r3.o $(OBJS)
    $(CC) -dynamiclib -o libr3.dylib r3.o $(CLIB)
    $(STRIP) -x libr3.dylib
    $(LS) libr3.dylib

# PUBLIC: Host using the shared lib:
host$(BIN_SUFFIX): $(HOST)
    $(CC) -o host$(BIN_SUFFIX) $(HOST) libr3.dylib $(CLIB)
    $(STRIP) host$(BIN_SUFFIX)
    $(LS) host$(BIN_SUFFIX)
    echo "export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH"
}

not-used: {
# PUBLIC: Static library (to distrirbute) -- does not work!
libr3.lib: r3.o
    ld -static -r -o libr3.lib r3.o
    $(STRIP) libr3.lib
    $(LS) libr3.lib
}

either config/id/2 = 2 [
    emit makefile-dyn
][
    emit makefile-so
] 


;
; EMIT FILE DEPENDENCIES
;
; !!! Because of how much scanning of header files to build temporary files
; there is, it's very hard to tell what kinds of changes to the source will
; necessitate a full build vs. an incremental one.  So the dependencies list
; is not as useful as it is for many makefiles, as full builds are usually
; required.
;

emit-file-deps: function [
    "Emit compiler and file dependency lines."
    files
    /dir path  ; from path
][
    for-each src files [
        obj: to-obj src
        src: unspaced pick [["$R/" src]["$S/" path src]] not dir
        emit [
            %objs/ obj ":" space src
            newline spaced-tab
            "$(CC) "
            ;flags space
            pick ["$(RFLAGS)" "$(HFLAGS)"] not dir
            space src
            space "-o" space %objs/ obj ; space src
            newline
            newline
        ]
    ]
]

emit {
### File build targets:
tmp-boot-block.c: $(SRC)/boot/tmp-boot-block.r
    $(REBOL) -sqw $(SRC)/tools/make-boot.r
}
emit newline

emit-file-deps file-base/core
emit-file-deps boot-extension-src

emit-file-deps/dir file-base/os %os/
emit-file-deps/dir os-specific-objs %os/


;
; OUTPUT MAKEFILE AND CREATE OBJ DIRECTORY
;
; Unfortunately, GNU make requires you use tab characters to indent, as part
; of the file format.  This code uses 4 spaces instead, but then converts to
; tabs at the last minute--so this Rebol source file doesn't need to have
; actual tab characters in it.
;
make-dir path-make
write-emitted/tabbed path-make/makefile
make-dir path-make/objs

print ["Created:" path-make/makefile]
